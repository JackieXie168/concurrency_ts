<!DOCTYPE html>
<!-- Sources at https://github.com/cplusplus/concurrent-ts -->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><!--[if lte IE 8]><script>document.createElement("nav");document.createElement("section");document.createElement("time");document.createElement("CXX-TITLEPAGE");document.createElement("CXX-DOCNUM");document.createElement("CXX-REVISES");document.createElement("CXX-EDITOR");document.createElement("CXX-EMAIL");document.createElement("CXX-TOC");document.createElement("CXX-CLAUSE");document.createElement("CXX-SECTION");document.createElement("CXX-EDNOTE");document.createElement("CXX-NOTE");document.createElement("CXX-REF");document.createElement("CXX-FUNCTION");document.createElement("CXX-SIGNATURE");document.createElement("CXX-EFFECTS");document.createElement("CXX-POSTCONDITIONS");document.createElement("CXX-REQUIRES");document.createElement("CXX-NOTES");document.createElement("CXX-EXAMPLE");document.createElement("CXX-RETURNS");document.createElement("CXX-REMARKS");document.createElement("CXX-CODEBLOCK");document.createElement("CXX-PUBLISH-BUTTON");</script><![endif]--><style>template {display: none !important;} /* injected by platform.js */</style><style>body {transition: opacity ease-in 0.2s; } 
body[unresolved] {opacity: 0; display: block; overflow: hidden; } 
</style><style shim-shadowdom-css="">style { display: none !important; }
cxx-function {
	display: block;
}

cxx-function:not(:last-child) {
	margin-bottom: 3ex;
}

cxx-function > dl {
	margin: 0px 0px 0px 2em;
}

cxx-function > pre {
	margin: 0px;
}cxx-signature {
	padding-left: 2em; display: block; text-indent: -2em;
}

cxx-signature.formatted {
	text-indent: 0px;
}cxx-attribute {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-attribute dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-attribute dd {
	margin-left: 0em;
}

cxx-attribute dd > ul, cxx-attribute dd > ol {
	clear: left;
}cxx-requires {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-requires dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-requires dd {
	margin-left: 0em;
}

cxx-requires dd > ul, cxx-requires dd > ol {
	clear: left;
}cxx-preconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-preconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-preconditions dd {
	margin-left: 0em;
}

cxx-preconditions dd > ul, cxx-preconditions dd > ol {
	clear: left;
}cxx-effects {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-effects dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-effects dd {
	margin-left: 0em;
}

cxx-effects dd > ul, cxx-effects dd > ol {
	clear: left;
}cxx-synchronization {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-synchronization dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-synchronization dd {
	margin-left: 0em;
}

cxx-synchronization dd > ul, cxx-synchronization dd > ol {
	clear: left;
}cxx-postconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-postconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-postconditions dd {
	margin-left: 0em;
}

cxx-postconditions dd > ul, cxx-postconditions dd > ol {
	clear: left;
}cxx-returns {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-returns dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-returns dd {
	margin-left: 0em;
}

cxx-returns dd > ul, cxx-returns dd > ol {
	clear: left;
}cxx-throws {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-throws dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-throws dd {
	margin-left: 0em;
}

cxx-throws dd > ul, cxx-throws dd > ol {
	clear: left;
}cxx-complexity {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-complexity dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-complexity dd {
	margin-left: 0em;
}

cxx-complexity dd > ul, cxx-complexity dd > ol {
	clear: left;
}cxx-exception-safety {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-exception-safety dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-exception-safety dd {
	margin-left: 0em;
}

cxx-exception-safety dd > ul, cxx-exception-safety dd > ol {
	clear: left;
}cxx-remarks {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-remarks dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-remarks dd {
	margin-left: 0em;
}

cxx-remarks dd > ul, cxx-remarks dd > ol {
	clear: left;
}cxx-error-conditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-error-conditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-error-conditions dd {
	margin-left: 0em;
}

cxx-error-conditions dd > ul, cxx-error-conditions dd > ol {
	clear: left;
}cxx-notes {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-notes dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-notes dd {
	margin-left: 0em;
}

cxx-notes dd > ul, cxx-notes dd > ol {
	clear: left;
}cxx-section {
	display: block;
}

cxx-section:target {
	background-color: inherit;
}

cxx-section:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-section header > h1 {
	display: inline; font-size: 100%;
}

cxx-section header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px;
}

cxx-section header:after {
	clear: both; display: block; content: " "; height: 0px;
}cxx-clause {
	display: block;
}

cxx-clause:target {
	background-color: inherit;
}

cxx-clause:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-clause header > h1 {
	display: inline; font-size: 100%;
}

cxx-clause header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px;
}

cxx-clause header:after {
	clear: both; display: block; content: " "; height: 0px;
}[is=cxx-table] {
	margin-left: auto; margin-right: auto; border-collapse: collapse; border: thin solid black;
}

[is=cxx-table] caption {
	white-space: nowrap;
}

[is=cxx-table] caption caption {
	display: inline;
}

[is=cxx-table] th, [is=cxx-table] td {
	border-style: solid none; border-color: black; border-width: thin; padding: 0px 0.25em;
}

[is=cxx-table].column-rules th, [is=cxx-table].column-rules td {
	border-left-style: solid; border-right-style: solid;
}

[is=cxx-table] th {
	border-bottom: medium double;
}

[is=cxx-table].center td {
	text-align: center;
}

[is=cxx-table].list td {
	border: medium none;
}cxx-figure {
	margin-left: auto; margin-right: auto;
}

cxx-figure figcaption {
	white-space: nowrap; text-align: center;
}

cxx-figure figcaption figcaption {
	display: inline;
}[is=cxx-definition-section] dt {
	font-weight: bold;
}

[is=cxx-definition-section] dd {
	margin-left: 0px;
}cxx-toc {
	display: block;
}

cxx-toc nav > ol {
	font-weight: bold;
}

cxx-toc ol {
	font-weight: normal; padding-left: 0px; margin-left: 0px;
}

cxx-toc li {
	list-style-type: none;
}

cxx-toc .marker {
	display: inline-block;
}

cxx-toc li .marker {
	width: 2em; text-align: left;
}

cxx-toc ol ol {
	margin-left: 2em;
}

cxx-toc li li .marker {
	width: 3em;
}

cxx-toc ol ol ol {
	margin-left: 3em;
}

cxx-toc li li li .marker {
	width: 3.5em;
}

cxx-toc ol ol ol ol {
	margin-left: 3.5em;
}

cxx-toc li li li li .marker {
	width: 4.5em;
}cxx-get-element-by-id {
	display: none;
}core-xhr {
	display: none;
}cxx-foreign-index {
	display: none;
}cxx-titlepage {
	display: block; min-height: 100%;
}

cxx-titlepage  {
	position: relative;
}

cxx-titlepage table {
	position: absolute; right: 0px; top: 0px;
}

cxx-titlepage h1 {
	position: absolute; top: 40%;
}

cxx-titlepage p.warning {
	position: absolute; bottom: 5%;
}

cxx-titlepage h1 {
	text-align: center;
}

cxx-titlepage th {
	text-align: left; vertical-align: top;
}cxx-ednote {
	display: block;
}

cxx-ednote aside {
	float: right; max-width: 40%; margin: 1ex; border: 1px dashed rgb(136, 136, 136); padding: 1ex; background-color: rgb(238, 238, 238);
}cxx-note .nowrap {
	white-space: nowrap;
}cxx-footnote {
	font-family: serif; white-space: normal; text-indent: initial;textIndent: initial; 
}

@media screen {
cxx-footnote aside {
	float: right; max-width: 30%; margin-left: 1em;
}


}

@media print {
cxx-footnote sup, cxx-footnote .marker {
	display: none;
}

aside {  }


}cxx-example {
	display: block;
}

cxx-example.inline {
	display: inline;
}

cxx-example .nowrap {
	white-space: nowrap;
}cxx-publish-button {
	display: block;
}cxx-codeblock {
	display: block;
}bnf-grammar {
	display: block; font-style: italic; margin-left: 0.35in;
}bnf-rule {
	display: block; margin-left: 0.6in;
}bnf-alt {
	display: block; margin-left: 1.2in;
}bnf-terminal {
	font-style: normal;
}</style>
  <meta charset="utf-8">
  
  <link rel="import" href="bower_components/cxx-html-doc-framework/framework.html">
<style shim-shadowdom-css="">/* Copyright 2014 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

@page {
    margin: 10%;
    @top-left { content: "Â© ISO/IEC"; font-size: 10pt; }
    @top-right { content: string(docnum); font-weight: bold; font-size: 10pt; }
    @bottom-left { content: string(current-section, last); font-size: 10pt; }
    @bottom-right { content: counter(page); font-size: 10pt; }
}
cxx-titlepage { page: title; page-break-after: always; }
@page title {
    @top-left { content: "Â© ISO 2014 â All rights reserved"; }
    @top-right { content: normal; }
    @bottom-left { content: normal; }
    @bottom-right { content: normal; }
}

@media screen {
    body { max-width: 7in;
           /* Make room for paragraph numbers. */
           margin-left: 2em }
}

@media print {
    html { font-size: 10pt; }
    *   pre, *   code { font-size: 8pt; }
    /* Note that only Prince generates clickable links. */
    *   a[href] { text-decoration:none; }
}

/* Needed to make the <cxx-titlepage>'s vertical spacing work. */
html, body {height: 100%}

cxx-docnum { string-set: docnum content(); }

cxx-clause { page-break-before: always; }
@media screen {
    cxx-clause, cxx-toc { margin-top: 3em; }
}

cxx-clause  header { font-size: 150%; }
cxx-toc  h1 { font-size: 150%; }
cxx-clause cxx-section  header { font-size: 117%; }
cxx-clause cxx-section cxx-section  header { font-size: 100%; }

[data-bookmark-label] { bookmark-label: attr(data-bookmark-label); }
h1 { bookmark-level: 1; }
cxx-toc  h1 { bookmark-level: 2; }
cxx-clause h1 { bookmark-level: 2; }
cxx-clause cxx-section h1 { bookmark-level: 3; }
cxx-clause cxx-section cxx-section h1 { bookmark-level: 4; }

*  .section-number { string-set: current-section "Â§ " content(); }

p {margin-top: .5em; margin-bottom: .5em}
p:first-child, ul, ol {margin-top: 0}

[para_num]::before { content: attr(para_num); float: left;
                     font-size: 70%; margin-left: -2.5em; width: 1.5em; text-align: right; }

del {text-decoration: line-through; background-color: red; color: #8B0040;}
ins {text-decoration: underline; background-color: yellow; color: #005100;}

pre {
    margin-left: 1em;
    margin-top: .5em;
    margin-bottom: .5em;
}
pre > code { display: inline-block; }


/* Use an em-dash for the list bullet. */
ul {
    list-style: none;
    /* Relative positioning on the 'ul' lets the absolutely-positioned
       marker align relative to it.*/
    position: relative;
}
ul li:before {
    content: "\2014";
    position: absolute; left: 10px;
}

/* This is here rather than inside elements/toc.html because browsers
   don't understand leader() or target-counter(), so they drop them
   inside the CSSOM. */
@media print {
    /* Generate page numbers in the table of contents. */
    cxx-toc  a[href]::after { content: leader(" . ") target-counter(attr(href), page); }

    cxx-footnote  aside { float: footnote; footnote-policy: line; }
}</style><title>Technical Specification for C++ Extensions for Concurrency, Working Draft</title></head>
<body>
<cxx-titlepage stage="draft">
    
    <table>
      
        <tbody><tr><th>Document Number:</th><td><cxx-docnum>N4256</cxx-docnum></td></tr>
      
      
        <tr><th>Date:</th><td><time pubdate="">2014-11-??</time></td></tr>
      
      
        <tr><th>Revises:</th><td><cxx-revises><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4107.html">N4107</a></cxx-revises></td></tr>
      
      
        <tr><th>Editor:</th><td><cxx-editor>
    Artur Laksberg<br>
    Microsoft Corp.<br>
    <cxx-email><a href="mailto:arturl@microsoft.com">arturl@microsoft.com</a></cxx-email>
  </cxx-editor></td></tr>
      
    </tbody></table>
    <h1>Working Draft, Technical Specification for C++ Extensions for Concurrency</h1>
    
      <p class="warning"><strong>Note: this is an early draft. Itâs known to be
      incomplet and incorrekt, and it has lots of b<span style="margin-left: -1.2pt; margin-right: 1pt">a</span>d<span style="width:1.5em"> </span>for<span style="margin-left:-3pt; margin-right:0.6pt">mat</span>ti<span style="position:relative; top:-0.15ex">n</span>g.</strong></p>
    
  </cxx-titlepage>

<cxx-toc>
    
    <nav>
      <h1>Contents</h1>
      
        
          <ol>
            
              <li><span class="marker">1</span><a href="#general">General</a>
        
          <ol>
            
              <li><span class="marker">1.1</span><a href="#general.namespaces">Namespaces, headers, and modifications to standard classes</a>
        
      </li>
            
              <li><span class="marker">1.2</span><a href="#general.plans">Future plans (Informative)</a>
        
      </li>
            
              <li><span class="marker">1.3</span><a href="#general.feature.test">Feature-testing recommendations (Informative)</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">2</span><a href="#futures"> Improvements to std::future&lt;T&gt; and Related APIs</a>
        
          <ol>
            
              <li><span class="marker">2.1</span><a href="#futures.general">General</a>
        
      </li>
            
              <li><span class="marker">2.2</span><a href="#header.future.synop">Header &lt;experimental/future&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">2.3</span><a href="#futures.unique_future">Class template future</a>
        
      </li>
            
              <li><span class="marker">2.4</span><a href="#futures.shared_future">Class template shared_future</a>
        
      </li>
            
              <li><span class="marker">2.5</span><a href="#futures.promise">Class template promise</a>
        
      </li>
            
              <li><span class="marker">2.6</span><a href="#futures.task">Class template packaged_task</a>
        
      </li>
            
              <li><span class="marker">2.7</span><a href="#futures.async"> Function template async</a>
        
      </li>
            
              <li><span class="marker">2.8</span><a href="#futures.when_all"> Function template when_all</a>
        
      </li>
            
              <li><span class="marker">2.9</span><a href="#futures.when_any"> Function template when_any</a>
        
      </li>
            
              <li><span class="marker">2.10</span><a href="#futures.when_any_back"> Function template when_any_back</a>
        
      </li>
            
              <li><span class="marker">2.11</span><a href="#futures.make_ready_future"> Function template make_ready_future</a>
        
      </li>
            
              <li><span class="marker">2.12</span><a href="#futures.make_exceptional_future">Function template make_exceptional_future</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      
    </nav>
  </cxx-toc>


<cxx-clause id="general">
    

    <section>
      <header><span class="section-number">1</span> <h1 data-bookmark-label="1 General">General</h1> <span style="float:right"><a href="#general">[general]</a></span></header>
      
  

  
  <cxx-section id="general.namespaces">
    

    <section>
      <header><span class="section-number">1.1</span> <h1 data-bookmark-label="1.1 Namespaces, headers, and modifications to standard classes">Namespaces, headers, and modifications to standard classes</h1> <span style="float:right"><a href="#general.namespaces">[general.namespaces]</a></span></header>
      
    

<p para_num="1" id="general.namespaces.1"><a id="general.namespaces.1"></a>
</p>
<p para_num="2" id="general.namespaces.2">
</p>
<p para_num="3" id="general.namespaces.3">
</p>
    <cxx-ednote>
    
    <aside><strong>Editor's note:</strong> This section reflects the consensus between the LWG and LEWG at the
    <a href="http://wiki.edg.com/twiki/bin/view/Wg21chicago2013/FundamentalsTS#What_can_go_into_a_TS">Chicago 2013</a> and
    <a href="http://wiki.edg.com/twiki/bin/view/Wg21issaquah/ChangesToExistingInTS">Issaquah 2014</a> meetings.</aside>
  </cxx-ednote>

    <p para_num="4" id="general.namespaces.4">Since the extensions described in this technical specification
    are experimental and not part of the C++ standard library, they
    should not be declared directly within namespace
    <code>std</code>.
    Unless otherwise specified, all components described in this technical specification either:
    </p>
    
    <ul>
      <li>modify an existing interface in the C++ Standard Library in-place,</li>
      <li>
        are declared in a namespace whose name appends <code>::experimental::concurrency_v1</code>
        to a namespace defined in the C++ Standard Library,
        such as <code>std</code>, or
      </li>
      <li>
        are declared in a subnamespace of a namespace described in the previous bullet,
        whose name is not the same as an existing subnamespace of namespace <code>std</code>.
      </li>
    </ul>

    <p para_num="5" id="general.namespaces.5">Each header described in this technical
    specification shall import the contents of
    <code>std::experimental::concurrency_v1</code> into
    <code>std::experimental</code> as if by</p>
    

    <pre><code>namespace std {
  namespace experimental {
    inline namespace concurrency_v1 {}
  }
}</code></pre>

    <p para_num="6" id="general.namespaces.6">Unless otherwise specified, references to other entities
    described in this technical specification are assumed to be
    qualified with <code>std::experimental::concurrency_v1::</code>,
    and references to entities described in the standard are assumed
    to be qualified with <code>std::</code>.</p>

    <p para_num="7" id="general.namespaces.7">Extensions that are expected to eventually be added to an
    existing header <code>&lt;meow&gt;</code> are provided inside the
    <code>&lt;experimental/meow&gt;</code> header, which shall include
    the standard contents of <code>&lt;meow&gt;</code> as if by</p>
    <pre><code>#include &lt;meow&gt;</code></pre>

    <p para_num="8" id="general.namespaces.8">New headers are also provided in the
    <code>&lt;experimental/&gt;</code> directory, but without such an
    <code>#include</code>.</p>

    <table is="cxx-table" id="tab.cxx.headers" class="list" columns="3">
    

    <caption>Table 1 â <wbr><span>C++ library headers</span></caption>
    
      
      <tbody><tr><td>
        <ul>
          <li><code>&lt;experimental/future&gt;</code></li>
        </ul>
      </td></tr>
    </tbody>
  </table>
  
    </section>
  </cxx-section>

  <cxx-section id="general.plans">
    

    <section>
      <header><span class="section-number">1.2</span> <h1 data-bookmark-label="1.2 Future plans (Informative)">Future plans (Informative)</h1> <span style="float:right"><a href="#general.plans">[general.plans]</a></span></header>
      
    

    <p para_num="1" id="general.plans.1">This section describes tentative plans for future versions of
    this technical specification and plans for moving content into
    future versions of the C++ Standard.</p>

    <p para_num="2" id="general.plans.2">The C++ committee intends to release a new version of this
    technical specification approximately every year, containing the
    library extensions we hope to add to a near-future version of the
    C++ Standard.  Future versions will define their contents in
    <code>std::experimental::concurrency_v2</code>,
    <code>std::experimental::concurrency_v3</code>, etc., with the
    most recent implemented version inlined into
    <code>std::experimental</code>.</p>

    <p para_num="3" id="general.plans.3">When an extension defined in this or a future version of this
    technical specification represents enough existing practice, it
    will be moved into the next version of the C++ Standard by
    removing the <code>experimental::concurrency_v<var>N</var></code>
    segment of its namespace and by removing the
    <code>experimental/</code> prefix from its header's path.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="general.feature.test">
    

    <section>
      <header><span class="section-number">1.3</span> <h1 data-bookmark-label="1.3 Feature-testing recommendations (Informative)">Feature-testing recommendations (Informative)</h1> <span style="float:right"><a href="#general.feature.test">[general.feature.test]</a></span></header>
      
    

    <p para_num="1" id="general.feature.test.1">
      For the sake of improved portability between partial implementations of various C++ standards,
      WG21 (the ISO technical committee for the C++ programming language) recommends
      that implementers and programmers follow the guidelines in this section concerning feature-test macros.
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    <a href="http://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">WG21's SD-6</a> makes similar recommendations for the C++ Standard itself.
    <span class="nowrap">â <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <p para_num="2" id="general.feature.test.2">
      Implementers who provide a new standard feature should define a 
macro with the recommended name,
      in the same circumstances under which the feature is available 
(for example, taking into account relevant command-line options),
      to indicate the presence of support for that feature.
      Implementers should define that macro with the value specified in
      the most recent version of this technical specification that they 
have implemented.
      The recommended macro name is "<code>__cpp_lib_experimental_</code>" followed by the string in the "Macro Name Suffix" column.
    </p>

    <p para_num="3" id="general.feature.test.3">
      Programmers who wish to determine whether a feature is available in an implementation should base that determination on
      the presence of the header (determined with <code>__has_include(&lt;header/name&gt;)</code>)
 and
      the state of the macro with the recommended name.
      (The absence of a tested feature may result in a program with 
decreased functionality, or the relevant functionality may be provided 
in a different way.
      A program that strictly depends on support for a feature can just 
try to use the feature unconditionally;
      presumably, on an implementation lacking necessary support, 
translation will fail.)
    </p>

    <table is="cxx-table" class="column-rules">
    

    <caption>Table 2 â <wbr><span>Significant features in this technical specification</span></caption>
    
      

      <thead>
        <tr>
          <th>Doc. No.</th>
          <th>Title</th>
          <th>Primary Section</th>
          <th>Macro Name Suffix</th>
          <th>Value</th>
          <th>Header</th>
        </tr>
      </thead>

      <!-- These rows are in the same order as their feature appears in this document. -->
      <tbody><tr>
        <td>N3875</td>
        <td>Improvements to std::future&lt;T&gt; and Related APIs</td>
        <td><cxx-ref to="futures"><a title="futures" href="#futures">2</a></cxx-ref></td>
        <td><code>future_continuations</code></td>
        <td>201410</td>
        <td><code>&lt;experimental/future&gt;</code></td>
      </tr>

    </tbody>
  </table>
    
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="futures">
    

    <section>
      <header><span class="section-number">2</span> <h1 data-bookmark-label="2  Improvements to std::future&lt;T&gt; and Related APIs"> Improvements to <code>std::future&lt;T&gt;</code> and Related APIs</h1> <span style="float:right"><a href="#futures">[futures]</a></span></header>
      


<cxx-section id="futures.general">
    

    <section>
      <header><span class="section-number">2.1</span> <h1 data-bookmark-label="2.1 General">General</h1> <span style="float:right"><a href="#futures.general">[futures.general]</a></span></header>
      

<p para_num="1" id="futures.general.1">

The extensions proposed here are an evolution of the functionality of
<code>std::future</code> and <code>std::shared_future</code>. The extensions
enable wait free composition of asynchronous operations. Class templates
<code>std::promise</code>, <code>std::packaged_task</code> and function
template <code>std::async</code> are also updated to be compatible with the
updated <code>std::future</code>.

</p>


    </section>
  </cxx-section>

  <cxx-section id="header.future.synop">
    

    <section>
      <header><span class="section-number">2.2</span> <h1 data-bookmark-label="2.2 Header &lt;experimental/future&gt; synopsis">Header &lt;experimental/future&gt; synopsis</h1> <span style="float:right"><a href="#header.future.synop">[header.future.synop]</a></span></header>
      
    

    <cxx-ednote>
    
    <aside><strong>Editor's note:</strong> 
      An additional editorial fix as in Fundamental v1 TS is applied in the declaration of <code>swap</code> for <code>packaged_task</code>
    </aside>
  </cxx-ednote>

    <pre><code>#include &lt;future&gt;

namespace std {
  namespace experimental {
  inline namespace concurrency_v1 {

    template &lt;class R&gt; class promise;
    template &lt;class R&gt; class promise&lt;R&amp;&gt;;
    template &lt;&gt; class promise&lt;void&gt;;

    template &lt;class R&gt;
    void swap(promise&lt;R&gt;&amp; x, promise&lt;R&gt;&amp; y) noexcept;

    template &lt;class R&gt; class future;
    template &lt;class R&gt; class future&lt;R&amp;&gt;;
    template &lt;&gt; class future&lt;void&gt;;
    template &lt;class R&gt; class shared_future;
    template &lt;class R&gt; class shared_future&lt;R&amp;&gt;;
    template &lt;&gt; class shared_future&lt;void&gt;;

    template &lt;class&gt; class packaged_task; // undefined
    template &lt;class R, class... ArgTypes&gt;
    class packaged_task&lt;R(ArgTypes...)&gt;;

    template &lt;class R, class... ArgTypes&gt;
    void swap(packaged_task&lt;R(ArgTypes...)&gt;&amp;, packaged_task&lt;R(ArgTypes...)&gt;&amp;) noexcept;

    template &lt;class F, class... Args&gt;
      future&lt;result_of_t&lt;decay_t&lt;F&gt;(decay_t&lt;Args&gt;...)&gt;&gt;
      async(F&amp;&amp; f, Args&amp;&amp;... args);
    template &lt;class F, class... Args&gt;
      future&lt;result_of_t&lt;decay_t&lt;F&gt;(decay_t&lt;Args&gt;...)&gt;&gt;
      async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);

    template &lt;class T&gt;
    future&lt;decay_t&lt;T&gt;&gt; make_ready_future(T&amp;&amp; value);
    future&lt;void&gt; make_ready_future();

    future&lt;T&gt; make_exceptional_future(exception_ptr value);
    template &lt;class T, class E&gt;
    future&lt;T&gt; make_exceptional_future(E ex);

    template &lt;class InputIterator&gt;
      <em>see below</em> when_all(InputIterator first, InputIterator last);
    template &lt;class... Futures&gt;
      <em>see below</em> when_all(Futures&amp;&amp;... futures);

    template &lt;class InputIterator&gt;
      <em>see below</em> when_any(InputIterator first, InputIterator last);
    template &lt;class... Futures&gt;
      <em>see below</em> when_any(Futures&amp;&amp;... futures);

    template &lt;class InputIterator&gt;
      <em>see below</em> when_any_back(InputIterator first, InputIterator last);

  } // namespace concurrency_v1
  } // namespace experimental

  template &lt;class R, class Alloc&gt;
  struct uses_allocator&lt;experimental::promise&lt;R&gt;, Alloc&gt;;

  template &lt;class R, class Alloc&gt;
  struct uses_allocator&lt;experimental::packaged_task&lt;R&gt;, Alloc&gt;;

} // namespace std</code></pre>
  
    </section>
  </cxx-section>

<cxx-section id="futures.unique_future">
    

    <section>
      <header><span class="section-number">2.3</span> <h1 data-bookmark-label="2.3 Class template future">Class template <code>future</code></h1> <span style="float:right"><a href="#futures.unique_future">[futures.unique_future]</a></span></header>
      


<p para_num="1" id="futures.unique_future.1">
The specification of all declarations within this sub-clause <cxx-ref to="futures.unique_future"><a title="futures.unique_future" href="#futures.unique_future">2.3</a></cxx-ref>
and its sub-clauses are the same as the corresponding declarations,
as specified in <cxx-ref in="cxx" to="futures.unique_future"></cxx-ref>,
unless explicitly specified otherwise.
</p>
<cxx-function para_num="2" id="futures.unique_future.2">
    
    <pre><code><cxx-signature>
</cxx-signature></code></pre>

    <dl>
      


    </dl>
  </cxx-function>

    <pre><code>namespace std {
  namespace experimental {
  inline namespace concurrency_v1 {

    template &lt;class R&gt;
    class future {
    public:
      future() noexcept;
      future(future &amp;&amp;) noexcept;
      future(const future&amp; rhs) = delete;
      future(future&lt;future&lt;R&gt;&gt;&amp;&amp; rhs) noexcept;
      ~future();
      future&amp; operator=(const future&amp; rhs) = delete;
      future&amp; operator=(future&amp;&amp;) noexcept;
      shared_future&amp;&lt;R&gt; share();

      // retrieving the value
      <em>see below</em> get();

      // functions to check state
      bool valid() const noexcept;
      bool is_ready() const;

      void wait() const;
      template &lt;class Rep, class Period&gt;
        future_status wait_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) const;
      template &lt;class Clock, class Duration&gt;
        future_status wait_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) const;

      // continuations
      template&lt;class F&gt;
        <em>see below</em> then(F&amp;&amp; func);
      template&lt;class F&gt;
        <em>see below</em> then(launch policy, F&amp;&amp; func);

    };

  } // namespace concurrency_v1
  } // namespace experimental
  } // namespace std</code></pre>

<p para_num="3" id="futures.unique_future.3">
In <cxx-ref in="cxx" to="futures.unique_future"></cxx-ref> between paragraphs 9 and 10, add the following:
</p>
<cxx-function para_num="4" id="futures.unique_future.4">
    
    <pre><code><cxx-signature>future(future&lt;future&lt;R&gt;&gt;&amp;&amp; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      
  
  <cxx-effects para_num="5" id="futures.unique_future.5">
    
    <dt>Effects:</dt><dd>Constructs a <code>future</code> object from the shared state referred to by
  <code>rhs</code>.

  
The <code>future</code> becomes ready when one of the following occurs:
<ul>
  <li>
    Both the outer and the inner <code>future</code>s are ready. The <code>future</code> inherits the value or the exception from the inner <code>future</code>.
  </li>
  
  <li>
    The outer <code>future</code> is ready but the inner <code>future</code> is invalid. The <code>future</code> gets an exception of type <code>std::future_error</code>, with an error code of <code>std::future_errc::broken_promise</code>.
  </li>
</ul>

</dd>
  </cxx-effects>
  <cxx-postconditions para_num="6" id="futures.unique_future.6">
    
    <dt>Postconditions:</dt><dd>
      <ul>
      <li></li>
      <li><code>valid() == true</code>.</li>
      <li><code>rhs.valid() == false</code>.</li>
    </ul>
  </dd>
  </cxx-postconditions>

    </dl>
  </cxx-function>

<p para_num="7" id="futures.unique_future.7">
After <cxx-ref in="cxx" to="futures.unique_future"></cxx-ref> paragraph 26, add the following:
</p>
<p para_num="8" id="futures.unique_future.8">

The member function template <code>then</code> provides a mechanism for attaching
a <i>continuation</i> to a <code>future</code> object, that will be executed
as specified below.

</p>
<cxx-function para_num="9" id="futures.unique_future.9">
    
    <pre><code><cxx-signature>
template&lt;class F&gt;
<em>see below</em> then(F&amp;&amp; func);

template&lt;class F&gt;
<em>see below</em> then(launch policy, F&amp;&amp; func);
</cxx-signature></code></pre>

    <dl>
      


<cxx-requires para_num="10" id="futures.unique_future.10">
    
    <dt>Requires:</dt><dd><code><em>INVOKE</em>(func, *this)</code> shall be a valid expression.</dd>
  </cxx-requires>

  <cxx-notes para_num="11" id="futures.unique_future.11">
    
    <dt>Notes:</dt><dd>The two functions differ only by input parameters. The first 
  takes a callable object which accepts a <code>future</code> object as a parameter. The
  second function takes a launch policy as the first
  parameter and a callable object as the second parameter.
  </dd>
  </cxx-notes>
  <cxx-effects para_num="12" id="futures.unique_future.12">
    
    <dt>Effects:</dt><dd>
    
    Both functions create a shared state that is associated with the returned
    <code>future</code> object. The further behavior of the functions is as follows.
    
    <ul>
      <li>The continuation <code>INVOKE(DECAY_COPY (std::forward&lt;F&gt;(func)))</code> is called when the object's shared state is ready (has a value or exception  stored).</li>
      <li>The continuation launches according to the specified launch policy, if it is provided.</li>
      <li>When the launch policy is not provided the continuation inherits
      the parent's launch policy.</li>
      <li>
      Any value returned from the continuation is stored as the result in the
      shared state of the resulting <code>future</code>. Any exception propagated from the execution of
      the continuation is stored as the exceptional result in the shared state of the resulting <code>future</code>.
      </li>
      <li>If the parent was created with <code>std::promise</code> or with a <code>packaged_task</code> (has
      no associated launch  policy), the continuation behaves the same as in the second
      overload with a policy argument of <code>launch::async | launch::deferred</code> and the
      same argument for <code>func</code>.</li>
      <li>If the parent has a policy of <code>launch::deferred</code>, then it is filled by
      calling <code>wait()</code> or <code>get()</code> on the resulting <code>future</code>.
      <a id="futures.unique_future.example"></a>
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <pre>auto f1 = async(launch::deferred, [] { return 1; });

auto f2 = f1.then([](future&lt;int&gt; n) { return 2; });

f2.wait(); // execution of f1 starts here, followed by f2
      </pre> 
    <span class="nowrap">â <em>end example</em> ]</span>
  </cxx-example>
      </li>
    </ul>
  </dd>
  </cxx-effects>

  <cxx-returns para_num="13" id="futures.unique_future.13">
    
    <dt>Returns:</dt><dd>
    The return type of <code>then</code> depends on the return type of the closure
    <code>func</code> as defined below:

    <ul>
      <li>
        When <code>result_of_t&lt;decay_t&lt;F&gt;(future&lt;R&gt;)&gt;</code>
        is <code>future&lt;R2&gt;</code>, the function returns <code>future&lt;R2&gt;</code>.
      </li>
      <li>
        Otherwise, the function returns <code>future&lt;result_of_t&lt;decay_t&lt;F&gt;(future&lt;R&gt;)&gt;&gt;</code>.
        <p>
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        The first rule above is called the <em>implicit unwrapping</em>. Without this rule,
        the return type of <code>then</code> taking a closure returning a
        <code>future&lt;R&gt;</code> would have been <code>future&lt;future&lt;R&gt;&gt;</code>.
        This rule avoids such nested <code>future</code> objects.
        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          The type of <code>f2</code> below is
          <code>future&lt;int&gt;</code> and not <code>future&lt;future&lt;int&gt;&gt;</code>:

    <span class="nowrap">â <em>end example</em> ]</span>
  </cxx-example>
    <span class="nowrap">â <em>end note</em> ]</span>
  </cxx-note></p><pre>future&lt;int&gt; f1 = g();
future&lt;int&gt; f2 = f1.then([](future&lt;int&gt; f) {
                    future&lt;int&gt; f3 = h();
                    return f3;
                 });
</pre>
        
    
      </li>
      <li>
        Unlike futures returned from <code>std::async</code> (see <cxx-ref in="cxx" to="futures.async"></cxx-ref> paragraph 4),
        the destructor of the <code>future</code> object returned from <code>then</code> will not block.
      </li>
    </ul>
  </dd>
  </cxx-returns>

  <cxx-postconditions para_num="14" id="futures.unique_future.14">
    
    <dt>Postconditions:</dt><dd>
  <ul>
  <li><code>valid() == false</code> on the original <code>future</code>;
    <code>valid() == true</code> on the <code>future</code> returned from <code>then.</code>
    <cxx-notes>
    
    <dt>Notes:</dt><dd>
      
      In case of implicit unwrapping, the validity of the <code>future</code> returned from
      <code>then</code> cannot be established until after the completion of the
      continuation. If it is not valid, the resulting <code>future</code>
      becomes ready with an exception of type <code>std::future_error</code>,
      with an error code of <code>std::future_errc::broken_promise</code>.
      
    </dd>
  </cxx-notes>
  </li>
  </ul>
  </dd>
  </cxx-postconditions>

    </dl>
  </cxx-function>

<cxx-function para_num="15" id="futures.unique_future.15">
    
    <pre><code><cxx-signature>bool is_ready() const;</cxx-signature></code></pre>

    <dl>
      
  
  <cxx-returns para_num="16" id="futures.unique_future.16">
    
    <dt>Returns:</dt><dd> <code>true</code> if the shared state is ready, <code>false</code> if it isn't.</dd>
  </cxx-returns>

    </dl>
  </cxx-function>


    </section>
  </cxx-section>

<cxx-section id="futures.shared_future">
    

    <section>
      <header><span class="section-number">2.4</span> <h1 data-bookmark-label="2.4 Class template shared_future">Class template <code>shared_future</code></h1> <span style="float:right"><a href="#futures.shared_future">[futures.shared_future]</a></span></header>
      

<p para_num="1" id="futures.shared_future.1">
The specification of all declarations within this sub-clause <cxx-ref to="futures.shared_future"><a title="futures.shared_future" href="#futures.shared_future">2.4</a></cxx-ref>
and its sub-clauses are the same as the corresponding declarations,
as specified in <cxx-ref in="cxx" to="futures.shared_future"></cxx-ref>,
unless explicitly specified otherwise.
</p>

<pre>  namespace std {
  namespace experimental {
  inline namespace concurrency_v1 {

    template &lt;class R&gt;
    class shared_future {
    public:
      shared_future() noexcept;
      shared_future(const shared_future &amp;) noexcept;
      shared_future(future &amp;&amp;) noexcept;
      shared_future(shared_future &amp;&amp;) noexcept;
      ~shared_future();
      shared_future&amp; operator=(const shared_future&amp; rhs);
      shared_future&amp; operator=(shared_future&amp;&amp;) noexcept;

      // retrieving the value
      <em>see below</em> get();

      // functions to check state
      bool valid() const noexcept;
      bool is_ready() const;

      void wait() const;
      template &lt;class Rep, class Period&gt;
        future_status wait_for(const chrono::duration&lt;Rep, Period&gt;&amp; rel_time) const;
      template &lt;class Clock, class Duration&gt;
        future_status wait_until(const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time) const;

      // continuations
      template&lt;class F&gt;
        <em>see below</em> then(F&amp;&amp; func) const;
      template&lt;class F&gt;
        <em>see below</em> then(launch policy, F&amp;&amp; func) const;

    };

  } // namespace concurrency_v1
  } // namespace experimental
  } // namespace std
</pre>

<p para_num="2" id="futures.shared_future.2">
After <cxx-ref in="cxx" to="futures.shared_future"></cxx-ref> paragraph 10, add the following:
</p>

<cxx-function para_num="3" id="futures.shared_future.3">
    
    <pre><code><cxx-signature>shared_future(future&lt;shared_future&lt;R&gt;&gt;&amp;&amp; rhs) noexcept;</cxx-signature></code></pre>

    <dl>
      
  
  
  <cxx-effects para_num="4" id="futures.shared_future.4">
    
    <dt>Effects:</dt><dd>Constructs a <code>shared_future</code> object from the shared state referred to by
  <code>rhs</code>.

The <code>shared_future</code> becomes ready when one of the following occurs:
<ul>
  <li>
    Both the outer <code>future</code> and the inner <code>shared_future</code> are ready. 
    The <code>shared_future</code> inherits the value or the exception from the inner <code>shared_future</code>.
  </li>
  
  <li>
    The outer <code>future</code> is ready but the inner <code>shared_future</code> is invalid.
    The <code>shared_future</code> gets an exception of type <code>std::future_error</code>, with an error code of <code>std::future_errc::broken_promise</code>.
  </li>
</ul>

</dd>
  </cxx-effects>
  <cxx-postconditions para_num="5" id="futures.shared_future.5">
    
    <dt>Postconditions:</dt><dd>
      <ul>
      <li><code>valid() == true</code>.</li>
      <li><code>rhs.valid() == false</code>.</li>
    </ul>
  </dd>
  </cxx-postconditions>

    </dl>
  </cxx-function>


<p para_num="6" id="futures.shared_future.6">
After <cxx-ref in="cxx" to="futures.shared_future"></cxx-ref> paragraph 28, add the following:
</p>

<p para_num="7" id="futures.shared_future.7">
The member function template <code>then</code> provides a mechanism for attaching
a <i>continuation</i> to a <code>shared_future</code> object, that will be executed
as specified below.
</p>

<cxx-function para_num="8" id="futures.shared_future.8">
    
    <pre><code><cxx-signature>
template&lt;class F&gt;
<em>see below</em> then(F&amp;&amp; func) const;

template&lt;class F&gt;
<em>see below</em> then(launch policy, F&amp;&amp; func) const;
</cxx-signature></code></pre>

    <dl>
      


<cxx-requires para_num="9" id="futures.shared_future.9">
    
    <dt>Requires:</dt><dd><code><em>INVOKE</em>(func, *this)</code> shall be a valid expression.</dd>
  </cxx-requires>

<cxx-notes para_num="10" id="futures.shared_future.10">
    
    <dt>Notes:</dt><dd>The two functions differ only by input parameters. The first
takes a callable object which accepts a <code>shared_future</code> object as a
parameter. The second function takes a launch
policy as the first parameter and a callable object which accepts a <code>shared_future</code> object as a
parameter, as the second parameter.
</dd>
  </cxx-notes>

<cxx-effects para_num="11" id="futures.shared_future.11">
    
    <dt>Effects:</dt><dd>
  
  Both functions create a shared state that is associated with the returned
  <code>future</code> object. The further behavior of the functions is as follows.
  
  <ul>
    <li>The continuation <code>INVOKE(DECAY_COPY (std::forward&lt;F&gt;(func)), *this)</code> is called when the object's shared state is ready (has a value or exception  stored).</li>
    <li>The continuation launches according to the specified policy, if it is provided.</li>
    <li>When the launch policy is not provided the continuation
    inherits the parent's launch policy.</li>
    <li>
    Any value returned from the continuation is stored as the result in the
    shared state of the resulting <code>future</code>. Any exception propagated from the execution of
    the continuation is stored as the exceptional result in the shared state of the resulting <code>future</code>.
    </li>
    <li>If the parent was created with <code>std::promise</code> (has no associated launch
    policy), the continuation behaves the same as in the second function with a policy
    argument of <code>launch::async | launch::deferred</code> and the same argument for <code>func</code>.</li>
    <li>If the parent has a policy of <code>launch::deferred</code>, then it is filled by
    calling <code>wait()</code> or <code>get()</code> on the resulting <code>future</code>.
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    This is similar to <code>future</code>. See example in <cxx-ref to="futures.unique_future"><a title="futures.unique_future" href="#futures.unique_future">2.3</a></cxx-ref>.
    
    <span class="nowrap">â <em>end note</em> ]</span>
  </cxx-note>
    </li>
  </ul>
</dd>
  </cxx-effects>

  <cxx-returns para_num="12" id="futures.shared_future.12">
    
    <dt>Returns:</dt><dd>
    The return type of <code>then</code> depends on the return type of the closure
    <code>func</code> as defined below:

    <ul>
      <li>
        When <code>result_of_t&lt;decay_t&lt;F&gt;(shared_future&lt;R&gt;)&gt;</code>
        is <code>future&lt;R2&gt;</code>, the function returns <code>future&lt;R2&gt;</code>.
      </li>
      <li>
        Otherwise, the function returns <code>future&lt;result_of_t&lt;decay_t&lt;F&gt;(shared_future&lt;R&gt;)&gt;&gt;</code>.
        <p>
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          This is the same as in <code>future</code>. See the notes on <code>future::then</code> return type in <cxx-ref to="futures.unique_future"><a title="futures.unique_future" href="#futures.unique_future">2.3</a></cxx-ref>.
        
    <span class="nowrap">â <em>end note</em> ]</span>
  </cxx-note>
      </p></li>
      <li>
        Unlike futures returned from <code>std::async</code> (see <cxx-ref in="cxx" to="futures.async"></cxx-ref> paragraph 4),
        the destructor of the <code>future</code> object returned from <code>then</code> will not block.
      </li>
    </ul>

  </dd>
  </cxx-returns>

<cxx-postconditions para_num="13" id="futures.shared_future.13">
    
    <dt>Postconditions:</dt><dd>
  <ul>
    <li>
    <code>valid() == true</code> on the original <code>shared_future</code> object.
    <code>valid() == true</code> on the <code>future</code> returned from <code>then.</code>

    <cxx-notes>
    
    <dt>Notes:</dt><dd>
      
      In case of implicit unwrapping, the validity of the <code>future</code> returned from
      <code>then</code> cannot be established until after the completion of the
      continuation. In such case, the resulting <code>future</code>
      becomes ready with an exception of type <code>std::future_error</code>,
      with an error code of <code>std::future_errc::broken_promise</code>.
      
    </dd>
  </cxx-notes>

    </li>
  </ul>
</dd>
  </cxx-postconditions>


    </dl>
  </cxx-function>

<cxx-function para_num="14" id="futures.shared_future.14">
    
    <pre><code><cxx-signature>bool is_ready() const;</cxx-signature></code></pre>

    <dl>
      

<cxx-returns para_num="15" id="futures.shared_future.15">
    
    <dt>Returns:</dt><dd> <code>true</code> if the shared state is ready, <code>false</code> if it isn't.</dd>
  </cxx-returns>
<cxx-remarks para_num="16" id="futures.shared_future.16">
    
    <dt>Remarks:</dt><dd>If the function has returned <code>true</code>, all subsequent invocations
on the same <code>shared_future</code> object will also return <code>true</code>.</dd>
  </cxx-remarks>

    </dl>
  </cxx-function>


    </section>
  </cxx-section>

  <cxx-section id="futures.promise">
    

    <section>
      <header><span class="section-number">2.5</span> <h1 data-bookmark-label="2.5 Class template promise">Class template <code>promise</code></h1> <span style="float:right"><a href="#futures.promise">[futures.promise]</a></span></header>
      
    

    <p para_num="1" id="futures.promise.1">
      The specification of all declarations within this sub-clause <cxx-ref to="futures.promise"><a title="futures.promise" href="#futures.promise">2.5</a></cxx-ref>
      and its sub-clauses are the same as the corresponding declarations,
      as specified in <cxx-ref in="cxx" to="futures.promise"></cxx-ref>,
      unless explicitly specified otherwise.
    </p>
    <p para_num="2" id="futures.promise.2">
      The <code>future</code> returned by the function <code>get_future</code> is the one defined in the <code>experimental</code>
      namespace (<cxx-ref to="futures.unique_future"><a title="futures.unique_future" href="#futures.unique_future">2.3</a></cxx-ref>).
    </p>

  
    </section>
  </cxx-section>

  <cxx-section id="futures.task">
    

    <section>
      <header><span class="section-number">2.6</span> <h1 data-bookmark-label="2.6 Class template packaged_task">Class template <code>packaged_task</code></h1> <span style="float:right"><a href="#futures.task">[futures.task]</a></span></header>
      
    

    <p para_num="1" id="futures.task.1">
      The specification of all declarations within this sub-clause <cxx-ref to="futures.task"><a title="futures.task" href="#futures.task">2.6</a></cxx-ref>
      and its sub-clauses are the same as the corresponding declarations,
      as specified in <cxx-ref in="cxx" to="futures.task"></cxx-ref>,
      unless explicitly specified otherwise.
    </p>
    <p para_num="2" id="futures.task.2">
      The <code>future</code> returned by the function <code>get_future</code> is the one defined in the <code>experimental</code>
      namespace (<cxx-ref to="futures.unique_future"><a title="futures.unique_future" href="#futures.unique_future">2.3</a></cxx-ref>).
    </p>

  
    </section>
  </cxx-section>

  <cxx-section id="futures.async">
    

    <section>
      <header><span class="section-number">2.7</span> <h1 data-bookmark-label="2.7  Function template async"> Function template <code>async</code></h1> <span style="float:right"><a href="#futures.async">[futures.async]</a></span></header>
      
    

    <p para_num="1" id="futures.async.1">
      The specification of all declarations within this sub-clause <cxx-ref to="futures.async"><a title="futures.async" href="#futures.async">2.7</a></cxx-ref>
      and its sub-clauses are the same as the corresponding declarations,
      as specified in <cxx-ref in="cxx" to="futures.async"></cxx-ref>,
      unless explicitly specified otherwise.
    </p>
    <p para_num="2" id="futures.async.2">
      The <code>future</code> returned by the function <code>async</code> is the one defined in the <code>experimental</code>
      namespace (<cxx-ref to="futures.unique_future"><a title="futures.unique_future" href="#futures.unique_future">2.3</a></cxx-ref>).
    </p>


    </section>
  </cxx-section>

<cxx-section id="futures.when_all">
    

    <section>
      <header><span class="section-number">2.8</span> <h1 data-bookmark-label="2.8  Function template when_all"> Function template <code>when_all</code></h1> <span style="float:right"><a href="#futures.when_all">[futures.when_all]</a></span></header>
      


<p para_num="1" id="futures.when_all.1">
The function template <code>when_all</code> creates a <code>future</code> object that
becomes ready when all elements in a set of <code>future</code> and <code>shared_future</code> objects
become ready.
</p>

<cxx-function para_num="2" id="futures.when_all.2">
    
    <pre><code><cxx-signature>
template &lt;class InputIterator&gt;
<em>see below</em>
future&lt;vector&lt;typename iterator_traits&lt;InputIterator&gt;::value_type&gt;&gt;
when_all(InputIterator first, InputIterator last);

template &lt;class... Futures&gt;
future&lt;tuple&lt;decay_t&lt;Futures&gt;...&gt;&gt; when_all(Futures&amp;&amp;... futures);
</cxx-signature></code></pre>

    <dl>
      


<cxx-requires para_num="3" id="futures.when_all.3">
    
    <dt>Requires:</dt><dd>
  <ul>
    <li>
      For the first overload, <code>iterator_traits&lt;InputIterator&gt;::value_type</code> shall be convertible to <code>future&lt;R&gt;</code>
      or <code>shared_future&lt;R&gt;</code>, but not both.
      If any of the <code>future&lt;R&gt;</code> or <code>shared_future&lt;R&gt;</code> objects are
      in invalid state (i.e. <code>valid() == false</code>), the behavior is undefined.
      
    </li>
    <li>
      For the second overload, 
      let <em><code>F<sub>i</sub></code></em> be the <em>i<sup>th</sup></em> type in <code>Futures</code>, 
      <em><code>U<sub>i</sub></code></em> be <code>remove_reference_t&lt;<em>F<sub>i</sub></em>&gt;</code>, and
      <em><code>f<sub>i</sub></code></em> be the <em>i<sup>th</sup></em> parameter in the function parameter 
      pack <code>futures</code>, where all indexing is zero-based. Then each <em><code>U<sub>i</sub></code></em>
      shall be the type <code>future&lt;<em>R<sub>i</sub></em>&gt;</code> or (possibly <code>const</code>) 
      <code>shared_future&lt;<em>R<sub>i</sub></em>&gt;</code>; and <code><em>f<sub>i</sub></em>.valid()</code> 
      shall be <code>true</code> for all <em>i</em>.
    </li>
  </ul>
</dd>
  </cxx-requires>

<cxx-notes para_num="4" id="futures.when_all.4">
    
    <dt>Notes:</dt><dd>
  <ul>
    <li>There are two variations of <code>when_all</code>. The first version takes a pair of
    <code>InputIterators</code>. The  second takes any arbitrary number of <code>future&lt;R0&gt;</code> and
    <code>shared_future&lt;R1&gt;</code> objects, where <code>R0</code>  and <code>R1</code> need not be the same type.</li>

    <li>Calling the first signature of <code>when_all</code> where <code>InputIterator</code> first
    equals last,  returns a <code>future</code> with an empty vector that is immediately
    ready.</li>

    <li>Calling the second signature of <code>when_all</code> with no arguments returns a
    <code>future&lt;tuple&lt;&gt;&gt;</code> that is  immediately ready.</li>
    </ul>
</dd>
  </cxx-notes>

<cxx-effects para_num="5" id="futures.when_all.5">
    
    <dt>Effects:</dt><dd>

<!-- M0when_all_effects -->

  <ul>
    <li>
    If any of the <code>future</code>s or <code>shared_future</code>s supplied
    to a call to <code>when_all</code> refer to deferred tasks
    that have not started execution, those tasks are executed before the call
    to <code>when_all</code> returns.
    </li>

    <li>
    The call to <code>when_all</code> does not wait for non-deferred tasks, or deferred tasks
    that have already started executing elsewhere, to complete before returning.
    </li>

    <li>
    Once all the <code>future</code>s and <code>shared_future</code>s supplied
    to the call to <code>when_all</code> are ready, the <code>future</code>s
    are moved, and the <code>shared_future</code>s are copied,

    into, correspondingly, <code>future</code>s or <code>shared_future</code>s
    of a new collection, which can be either <code>tuple</code> or a <code>vector</code>
    as described below. The order of the objects in the collection matches the order
    of the arguments supplied to <code>when_all</code>.

    </li><li>
    The collection is then stored as the result in a newly created shared state.
    </li>

    <li>
    A new <code>future</code> object that refers to the shared state
    is created. The exact type of the <code>future</code> is further described below.
    </li>

    <li>The <code>future</code> returned by <code>when_all</code> will not throw an exception, but the
    <code>future</code>s and <code>shared_future</code>s held in the output collection may.</li>
  </ul>
</dd>
  </cxx-effects>

<cxx-postconditions para_num="6" id="futures.when_all.6">
    
    <dt>Postconditions:</dt><dd>
  <ul>
    <li><code>valid() == true</code>.</li>
    <li>All input <code>future&lt;T&gt;</code>s <code>valid() == false</code>.</li>
    <li>All input<code>shared_future&lt;T&gt;</code> <code>valid() == true</code>.</li>
  </ul>
</dd>
  </cxx-postconditions>

<cxx-returns para_num="7" id="futures.when_all.7">
    
    <dt>Returns:</dt><dd>
  <ul>
    <li>A future object that becomes ready when all the input
      <code>future</code>s/<code>shared_future</code>s are ready.
    </li>
  </ul>
</dd>
  </cxx-returns>


    </dl>
  </cxx-function>

    </section>
  </cxx-section>

<!--             -->
<!-- M00when_any -->
<!--             -->

<cxx-section id="futures.when_any">
    

    <section>
      <header><span class="section-number">2.9</span> <h1 data-bookmark-label="2.9  Function template when_any"> Function template <code>when_any</code></h1> <span style="float:right"><a href="#futures.when_any">[futures.when_any]</a></span></header>
      

<p para_num="1" id="futures.when_any.1"></p>


The function template <code>when_any</code> creates a <code>future</code> object that
becomes ready when at least one element in a set of <code>future</code> and <code>shared_future</code> objects
becomes ready.
<p para_num="2" id="futures.when_any.2"></p>

<cxx-function para_num="3" id="futures.when_any.3">
    
    <pre><code><cxx-signature>
template &lt;class InputIterator&gt;
future&lt;vector&lt;typename iterator_traits&lt;InputIterator&gt;::value_type&gt;&gt;
when_any(InputIterator first, InputIterator last);

template &lt;class... Futures&gt;
future&lt;tuple&lt;decay_t&lt;Futures&gt;...&gt;&gt; when_any(Futures&amp;&amp;... futures);
</cxx-signature></code></pre>

    <dl>
      


<cxx-requires para_num="4" id="futures.when_any.4">
    
    <dt>Requires:</dt><dd>
  <ul>
    <li>
      
      For the first overload, <code>iterator_traits&lt;InputIterator&gt;::value_type</code> shall be convertible to <code>future&lt;R&gt;</code>
      or <code>shared_future&lt;R&gt;</code>, but not both.
      If any of the <code>future&lt;R&gt;</code> or <code>shared_future&lt;R&gt;</code> objects are
      in invalid state (i.e. <code>valid() == false</code>), the behavior is undefined.
      
    </li>
    <li>
      For the second overload, 
      let <em><code>F<sub>i</sub></code></em> be the <em>i<sup>th</sup></em> type in <code>Futures</code>, 
      <em><code>U<sub>i</sub></code></em> be <code>remove_reference_t&lt;<em>F<sub>i</sub></em>&gt;</code>, and
      <em><code>f<sub>i</sub></code></em> be the <em>i<sup>th</sup></em> parameter in the function parameter 
      pack <code>futures</code>, where all indexing is zero-based. Then each <em><code>U<sub>i</sub></code></em>
      shall be the type <code>future&lt;<em>R<sub>i</sub></em>&gt;</code> or (possibly <code>const</code>) 
      <code>shared_future&lt;<em>R<sub>i</sub></em>&gt;</code>; and <code><em>f<sub>i</sub></em>.valid()</code> 
      shall be <code>true</code> for all <em>i</em>.
    </li>
  </ul>
</dd>
  </cxx-requires>

<cxx-notes para_num="5" id="futures.when_any.5">
    
    <dt>Notes:</dt><dd>
<ul>
  <li>There are two variations of <code>when_any</code>. The first version takes a pair of
  <code>InputIterators</code>. The  second takes any arbitrary number of <code>future&lt;R&gt;</code> and
  <code>shared_future&lt;R&gt;</code> objects, where <code>R</code> need  not be the same type.</li>

  <li>Calling the first signature of <code>when_any</code> where <code>InputIterator</code> <code>first</code>
  equals <code>last</code>, returns a <code>future</code> with an empty vector that is immediately
  ready.</li>

  <li>Calling the second signature of <code>when_any</code> with no arguments returns a
  <code>future&lt;tuple&lt;&gt;&gt;</code> that is immediately ready.</li>
</ul>
</dd>
  </cxx-notes>

<cxx-effects para_num="6" id="futures.when_any.6">
    
    <dt>Effects:</dt><dd>

<!-- M0when_any_effects -->

  <ul>
    <li>
    Each of the <code>future</code>s and <code>shared_future</code>s supplied to
    <code>when_any</code> is checked in the order supplied.
    If a given <code>future</code> or
    <code>shared_future</code> refers to a deferred task that has not yet started execution,
    then no further <code>future</code>s or <code>shared_future</code>s are checked,
    and that task is executed.
    </li>

    <li>
    The call to <code>when_any</code> does not wait for non-deferred tasks, or deferred tasks
    that have already started executing elsewhere, to complete before returning.
    </li>

    <li>
    Once at least one of the <code>future</code>s or <code>shared_future</code>s
    supplied to the call to <code>when_any</code> are ready, the <code>future</code>s
    are moved, and the <code>shared_future</code>s are copied

    into, correspondingly, <code>future</code>s or <code>shared_future</code>s
    of a new collection, which can be either <code>tuple</code> or a <code>vector</code>
    as described below.

    </li><li>
    The order of the objects in the collection matches the order
    of the arguments supplied to <code>when_any</code>.
    </li>

    <li>
    The collection is then stored as the result in the newly created shared state.
    </li>

    <li>
    A new <code>future</code> object that refers to the shared state
    is created. The exact type of the <code>future</code> is further described below.
    </li>

    <li>The <code>future</code> returned by <code>when_any</code> will not throw
    an exception, but the <code>future</code>s and <code>shared_future</code>s
    held in the  output collection may.
    </li>
  </ul>
</dd>
  </cxx-effects>

<cxx-postconditions para_num="7" id="futures.when_any.7">
    
    <dt>Postconditions:</dt><dd>
  <ul>
    <li><code>valid() == true</code>.</li>
    <li>All input <code>future&lt;T&gt;</code>s <code>valid() == false</code>.</li>
    <li>All input<code>shared_future&lt;T&gt;</code> <code>valid() == true</code>.</li>
  </ul>
</dd>
  </cxx-postconditions>

<cxx-returns para_num="8" id="futures.when_any.8">
    
    <dt>Returns:</dt><dd>
<ul>
  <li>A future object that becomes ready when any of the input
    <code>future</code>s/<code>shared_future</code>s are ready.
  </li>
</ul>
</dd>
  </cxx-returns>


    </dl>
  </cxx-function>

    </section>
  </cxx-section>

<!--                  -->
<!-- M00when_any_back -->
<!--                  -->

<cxx-section id="futures.when_any_back">
    

    <section>
      <header><span class="section-number">2.10</span> <h1 data-bookmark-label="2.10  Function template when_any_back"> Function template <code>when_any_back</code></h1> <span style="float:right"><a href="#futures.when_any_back">[futures.when_any_back]</a></span></header>
      

<p para_num="1" id="futures.when_any_back.1">
A new section 30.6.12 shall be inserted at the end of <cxx-ref in="cxx" to="futures"></cxx-ref>. Below is the content of that section.
</p>

<p para_num="2" id="futures.when_any_back.2">
The function template <code>when_any_back</code> creates a <code>future</code> object that
becomes ready when at least one element in a set of <code>future</code> and <code>shared_future</code> objects
becomes ready. The ready <code>future</code> or <code>shared_future</code> may be identified in
constant time.
</p>

<cxx-function para_num="3" id="futures.when_any_back.3">
    
    <pre><code><cxx-signature>
template &lt;class InputIterator&gt;
future&lt;vector&lt;typename iterator_traits&lt;InputIterator&gt;::value_type&gt;&gt;
when_any_back(InputIterator first, InputIterator last);
</cxx-signature></code></pre>

    <dl>
      


<cxx-requires para_num="4" id="futures.when_any_back.4">
    
    <dt>Requires:</dt><dd>
  
      <code>iterator_traits&lt;InputIterator&gt;::value_type</code> shall be convertible to <code>future&lt;R&gt;</code>
      or <code>shared_future&lt;R&gt;</code>.
      If any of the <code>future&lt;R&gt;</code> or <code>shared_future&lt;R&gt;</code> objects are
      in invalid state (i.e. <code>valid() == false</code>), the behavior is undefined.
  
</dd>
  </cxx-requires>

<cxx-effects para_num="5" id="futures.when_any_back.5">
    
    <dt>Effects:</dt><dd>

<!-- M0when_any_back_effects -->

  <ul>
    <li>
    Each of the <code>future</code>s and <code>shared_future</code>s supplied to
    <code>when_any_back</code> is checked in the order supplied.
    If a given <code>future</code> or
    <code>shared_future</code> refers to a deferred task that has not yet started execution,
    then no further <code>future</code>s or <code>shared_future</code>s are checked,
    and that task is executed.
    </li>

    <li>
    The call to <code>when_any_back</code> does not wait for non-deferred tasks, or deferred tasks
    that have already started executing elsewhere, to complete before returning.
    </li>

    <li>
    Once at least one of the <code>future</code>s or <code>shared_future</code>s
    supplied to the call to <code>when_any_back</code> are ready, the <code>future</code>s
    are moved, and the <code>shared_future</code>s are copied

    into, correspondingly, <code>future</code>s or <code>shared_future</code>s
    of a new collection, which can be either <code>tuple</code> or a <code>vector</code>
    as described below.

    </li><li>
    If the collection passed into <code>when_any_back</code> is non-empty (i.e.,
    <code>first != last</code>),

    the last <code>future</code> or <code>shared_future</code> in the output collection
    is guaranteed to be in the ready state. The order of other elements in the
    collection is unspecified.
    </li>

    <li>
    The collection is then stored as the result in the shared state.
    </li>

    <li>
    A new <code>future</code> object that refers to the newly created shared state
    is created. The exact type of the <code>future</code> is further described below.
    </li>

    <li>The <code>future</code> returned by <code>when_any_back</code> will not throw
    an exception, but the <code>future</code>s and <code>shared_future</code>s
    held in the  output collection may.
    </li>
  </ul>
</dd>
  </cxx-effects>

<cxx-postconditions para_num="6" id="futures.when_any_back.6">
    
    <dt>Postconditions:</dt><dd>
  <ul>
    <li><code>valid() == true</code>.</li>
    <li>All input <code>future&lt;T&gt;</code>s <code>valid() == false</code>.</li>
    <li>All input<code>shared_future&lt;T&gt;</code> <code>valid() == true</code>.</li>
  </ul>
</dd>
  </cxx-postconditions>

<cxx-returns para_num="7" id="futures.when_any_back.7">
    
    <dt>Returns:</dt><dd>
  <ul>
    <li>A future object that becomes ready when any of the input
      <code>future</code>s/<code>shared_future</code>s are ready.
    </li>
  </ul>
</dd>
  </cxx-returns>


    </dl>
  </cxx-function>

    </section>
  </cxx-section>

<cxx-section id="futures.make_ready_future">
    

    <section>
      <header><span class="section-number">2.11</span> <h1 data-bookmark-label="2.11  Function template make_ready_future"> Function template <code>make_ready_future</code></h1> <span style="float:right"><a href="#futures.make_ready_future">[futures.make_ready_future]</a></span></header>
      

<p para_num="1" id="futures.make_ready_future.1">
A new section 30.6.13 shall be inserted at the end of <cxx-ref in="cxx" to="futures"></cxx-ref>. Below is the content of that section.
</p>

<cxx-function para_num="2" id="futures.make_ready_future.2">
    
    <pre><code><cxx-signature>
template &lt;class T&gt;
future&lt;decay_t&lt;T&gt;&gt; make_ready_future(T&amp;&amp; value);

future&lt;void&gt; make_ready_future();
  </cxx-signature></code></pre>

    <dl>
      
  

  <cxx-effects para_num="3" id="futures.make_ready_future.3">
    
    <dt>Effects:</dt><dd> The value that is passed in to the function is moved to the shared state of the returned <code>future</code> if it
  is an rvalue. Otherwise the value is copied to the shared state of the returned <code>future</code>.
  </dd>
  </cxx-effects>

  <cxx-returns para_num="4" id="futures.make_ready_future.4">
    
    <dt>Returns:</dt><dd>
    <ul>
      <li><code>future&lt;decay_t&lt;T&gt;&gt;</code>, if function is given a value of type <code>T</code>.</li>
      <li><code>future&lt;void&gt;</code>, if the function is not given any inputs. </li>
    </ul>
  </dd>
  </cxx-returns>

  <cxx-postconditions para_num="5" id="futures.make_ready_future.5">
    
    <dt>Postconditions:</dt><dd>
    <ul>
      <li>Returned <code>future&lt;decay_t&lt;T&gt;&gt;, valid() == true</code>.</li>
      <li>Returned <code>future&lt;decay_t&lt;T&gt;&gt;, is_ready() == true</code>.</li>
    </ul>
  </dd>
  </cxx-postconditions>

    </dl>
  </cxx-function>

    </section>
  </cxx-section>

<cxx-section id="futures.make_exceptional_future">
    

    <section>
      <header><span class="section-number">2.12</span> <h1 data-bookmark-label="2.12 Function template make_exceptional_future">Function template <code>make_exceptional_future</code></h1> <span style="float:right"><a href="#futures.make_exceptional_future">[futures.make_exceptional_future]</a></span></header>
      

<p para_num="1" id="futures.make_exceptional_future.1">
A new section 30.6.13 shall be inserted at the end of <cxx-ref in="cxx" to="futures"></cxx-ref>. Below is the content of that section.
</p>

<cxx-function para_num="2" id="futures.make_exceptional_future.2">
    
    <pre><code><cxx-signature>
template &lt;class T&gt;
future&lt;T&gt; make_exceptional_future(exception_ptr ex);
</cxx-signature></code></pre>

    <dl>
      
  

  <cxx-effects para_num="3" id="futures.make_exceptional_future.3">
    
    <dt>Effects:</dt><dd>As if
  <cxx-codeblock>
    
    <pre><code>promise&lt;T&gt; p;
p.set_exception(ex);
return p.get_future();</code></pre>
  </cxx-codeblock>
  </dd>
  </cxx-effects>


    </dl>
  </cxx-function>
<cxx-function para_num="4" id="futures.make_exceptional_future.4">
    
    <pre><code></code></pre>

    <dl>
      
  <cxx-codeblock>
    
    <pre><code>template &lt;class T, class E&gt;
future&lt;T&gt; make_exceptional_future(E ex);</code></pre>
  </cxx-codeblock>

  <cxx-effects para_num="5" id="futures.make_exceptional_future.5">
    
    <dt>Effects:</dt><dd>As if
  <cxx-codeblock>
    
    <pre><code>promise&lt;T&gt; p;
p.set_exception(make_exception_ptr(ex));
return p.get_future();</code></pre>
  </cxx-codeblock>
  </dd>
  </cxx-effects>


    </dl>
  </cxx-function>

    </section>
  </cxx-section>




    </section>
  </cxx-clause>




</body></html>