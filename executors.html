<cxx-clause id="executors">
  <h1>Executors and Schedulers</h1>

  <cxx-section id="exec.general">
    <h1>General</h1>
<p>
This proposal includes two abstract base classes, <code>executor</code> and
<code>scheduled_executor</code> (the latter of which inherits from the former); several
concrete classes that inherit from <code>executor</code> or <code>scheduled_executor</code>; and
several utility functions.</p>

  </cxx-section>

    <table is="cxx-table" class="column-rules">
      <caption>Executors library summary</caption>

      <thead>
        <tr>
          <th>Subclause</th>
          <th>Header(s)</th>
        </tr>
      </thead>
      <tr>
        <td>[executors.base]</td>
        <td><code>&lt;executor></code></td>
      </tr>
      <tr>
        <td>[executors.classes]</td>
        <td></td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;[executors.classes.thread_pool]</td>
        <td><code>&lt;thread_pool></code></td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;[executors.classes.serial]</td>
        <td><code>&lt;serial_executor></code></td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;[executors.classes.loop]</td>
        <td><code>&lt;loop_executor></code></td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;[executors.classes.inline]</td>
        <td><code>&lt;inline_executor></code></td>
      </tr>
      <tr>
        <td>&nbsp;&nbsp;[executors.classes.thread]</td>
        <td><code>&lt;thread_per_task_executor></code></td>
      </tr>
    </table>

<cxx-section id="executors.base">
<h1>Executor base classes</h1>

<p>
The <code>&lt;executor></code> header defines abstract base classes for executors, as well as
non-member functions that operate at the level of those abstract base classes. </p>
</cxx-section>

<cxx-section id="executor.synop">
<h1>Header <code>&lt;experimental/executor></code> synopsis</h1>

<pre>
namespace std {
namespace experimental {
inline namespace concurrency_v1 {

    class executor;
    class scheduled_executor;

} // namespace concurrency_v1
} // namespace experimental
} // namespace std
</pre>
</cxx-section>

<cxx-section id="executors.base.executor">
<h1>Class <code>executor</code></h1>

<p>
Class <code>executor</code> is an abstract base class defining an abstract interface of
objects that are capable of scheduling and coordinating work submitted by
clients. Work units submitted to an executor may be executed in one or more
separate threads. Implementations are required to avoid data races when work
units are submitted concurrently.</p>

<p>
All closures are defined to execute on some thread, but which thread is largely
unspecified. As such accessing a <code>thread_local</code> variable is defined behavior,
though it is unspecified which thread's <code>thread_local</code> will be accessed.</p>

<p>
The initiation of a work unit is not necessarily ordered with respect to other
initiations. </p>
<p><cxx-note> Concrete executors may, and often do, provide stronger
initiation order guarantees. Users may, for example, obtain serial execution
guarantees by using the <code>serial_executor</code> wrapper.</cxx-note> </p>

<p>There is no defined ordering of the execution or completion of closures added to the
executor. </p>

<p>
<cxx-note> The consequence is that closures should not wait on other
closures executed by that executor. Mutual exclusion for critical sections is
fine, but it can't be used for signalling between closures. Concrete executors
may provide stronger execution order guarantees.</cxx-note> </p>

<pre>
    class executor {
    public:
        virtual ~executor();
        virtual void add(function&lt;void()> closure) =0;
        virtual size_t uninitiated_task_count() const =0;
    };
</pre>

<cxx-function>
<cxx-signature>executor::~executor()</cxx-signature>
<cxx-Effects> Destroys the executor.</cxx-Effects>
<cxx-Synchronization> All closure initiations happen before the completion of the
executor destructor. <cxx-Note> This means that closure initiations don't leak
past the executor lifetime, and programmers can protect against data races with
the destruction of the environment. There is no guarantee that all closures that
have been added to the executor will execute, only that if a closure executes it
will be initiated before the destructor executes. In some concrete subclasses
the destructor may wait for task completion and in others the destructor may
discard uninitiated tasks.</cxx-Note></cxx-Synchronization>
<cxx-remarks> The behavior is undefined if the executor is destroyed during the 
execution of a closure running on that executor object.
<cxx-note> One possible behavior is deadlock.</cxx-note></cxx-remarks>
</cxx-function>

<cxx-function>
<cxx-signature>void executor::add(std::function&lt;void> closure);</cxx-signature>
<cxx-Effects> The specified function object shall be scheduled for execution by the
executor at some point in the future. May throw exceptions if add cannot
complete (due to shutdown or other conditions).</cxx-Effects>
<cxx-Synchronization> completion of closure on a particular thread happens before
destruction of that thread's thread-duration variables.
  <cxx-note> The consequence is that closures may use thread-duration variables, 
  even though in general executors don't make guarantees about which thread an
  individual closure executes in.
  </cxx-note>
</cxx-Synchronization>
<cxx-Requires> The invoked closure should not throw an exception.</cxx-Requires>
<cxx-Throws>An implementation may throw exceptions if <code>add</code> cannot complete 
(due to shutdown or other conditions)</cxx-Throws>
</cxx-function>

<cxx-function>
<cxx-signature>size_t executor::uninitiated_task_count();</cxx-signature>
<cxx-Returns> the number of function objects waiting to be executed. <cxx-notes> this is
intended for logging/debugging and for coarse load balancing decisions. Other
uses are inherently risky because other threads may be executing or adding
closures.</cxx-notes></cxx-Returns>
</cxx-function>

</cxx-section>

<cxx-section id="executors.base.scheduled_executor">
<h1>Class <code>scheduled_executor</code></h1>

<p>
Class <code>scheduled_executor</code> is an abstract base class that extends the executor
interface by allowing clients to pass in work items that will be executed some
time in the future.
</p>

<pre>
    class scheduled_executor : public executor {
    public:
        virtual void add_at(const chrono::system_clock::time_point&amp; abs_time,
                            function&ltvoid()> closure) = 0;
        virtual void add_after(const chrono::system_clock::duration&amp; rel_time,
                               function&ltvoid()> closure) = 0;
    };
</pre>

<cxx-function>
<cxx-signature>void add_at(const chrono::system_clock::time_point&amp; abs_time, function&lt;void()> closure);</cxx-signature>
<cxx-Effects> The specified function object shall be scheduled for execution by the executor at
some point in the future no sooner than the time represented by <code>abs_time</code>.</cxx-Effects>
<cxx-Synchronization> completion of closure on a particular thread happens before
destruction of that thread's thread-duration variables.</cxx-Synchronization>
<cxx-Requires> The invoked closure should not throw an exception.</cxx-Requires>
</cxx-function>

<cxx-function>
<cxx-signature>void add_after(const chrono::system_clock::duration&amp; rel_time, function&lt;void()> closure);</cxx-signature>
<cxx-Effects> The specified function object shall be scheduled for execution by the
executor at some point in the future no sooner than time <code>rel_time</code> from now.</cxx-Effects>
<cxx-Synchronization> completion of closure on a particular thread happens before
destruction of that thread's thread-duration variables.</cxx-Synchronization>
<cxx-Requires> The invoked closure should not throw an exception.</cxx-Requires>
</cxx-function>

</cxx-section>

<cxx-section id="executors.classes">
<h1>Concrete executor classes</h1>

This section defines executor classes that encapsulate a variety of closure-
execution policies.

<cxx-section id="executors.classes.thread_pool">
<h1>Class <code>thread_pool</code></h1>

</cxx-section>

<cxx-section id="executors.classes.thread_pool.synop">
<h1>Header <code>&lt;experimental/thread_pool></code> synopsis</h1>

<pre>
namespace std {
namespace experimental {
inline namespace concurrency_v1 {

  class thread_pool;

} // namespace concurrency_v1
} // namespace experimental
} // namespace std
</pre>

<p>
Class <code>thread_pool</code> is a simple thread pool class that creates a fixed number of
threads in its constructor and that multiplexes closures onto them.
</p>

<pre>
class thread_pool : public scheduled_executor {
   public:
   explicit thread_pool(int num_threads);
   ~thread_pool();
   // [executor methods omitted]
};
</pre>

<cxx-function>
<cxx-signature>thread_pool::thread_pool(int num_threads)</cxx-signature>
<cxx-Effects> Creates an executor that runs closures on <code>num_threads</code> threads.</cxx-Effects>
<cxx-Throws><code>system_error</code> if the threads can't be created and started.</code></cxx-Throws>
<cxx-error-conditions>
<ul>
<li>
<code>resource_unavailable_try_again</code> &mdash; the system lacked
the necessary resources to create another thread, or the system-imposed limit on
the number of threads in a process would be exceeded.
</li>
</ul>
</cxx-error-conditions>
</cxx-function>

<cxx-function>
<cxx-signature>thread_pool::~thread_pool()</cxx-signature>
<cxx-Effects> Waits for closures (if any) to complete, then joins and destroys the threads.</cxx-Effects>
</cxx-function>

</cxx-section>

<cxx-section id="executors.classes.serial">
<h1>Class <code>serial_executor</code></h1>

</cxx-section>

<cxx-section id="executors.classes.serial.synop">
<h1>Header <code>&lt;experimental/serial_executor></code> synopsis</h1>

<pre>
namespace std {
namespace experimental {
inline namespace concurrency_v1 {

  class serial_executor;

} // namespace concurrency_v1
} // namespace experimental
} // namespace std
</pre>

<p>
Class <code>serial_executor</code> is an adaptor that runs its closures by scheduling them
on another (not necessarily single-threaded) executor. It runs added closures
inside a series of closures added to an underlying executor in such a way so
that the closures execute serially. For any two closures <code>c1</code> and <code>c2</code> added to
a <code>serial_executor</code> <code>e</code>, either the completion of <code>c1</code> happens before
(as per <cxx-ref in="cxx" to="intro.multithread"></cxx-ref>) the execution of <code>c2</code> begins, or vice versa. 
If <code>e.add(c1)</code> happens before <code>e.add(c2)</code>, then <code>c1</code> is 
executed before <code>c2</code>.</p>

<pre>
class serial_executor : public executor {
public
    explicit serial_executor(executor&amp; underlying_executor);
    virtual ~serial_executor();
    executor&amp; underlying_executor();
    // [executor methods omitted]
};
</pre>

<cxx-function>
<cxx-signature>serial_executor::serial_executor(executor&amp; underlying_executor)</cxx-signature>
<cxx-Effects> Creates a <code>serial_executor</code> that executes closures in FIFO order by
passing them to <code>underlying_executor</code>.
</cxx-Effects>
<cxx-notes> several <code>serial_executor</code> objects may share a single underlying executor. </cxx-notes>
</cxx-function>

<cxx-function>
<cxx-signature>serial_executor::~serial_executor()</cxx-signature>
<cxx-Effects> Finishes running any currently executing closure, then destroys all remaining
closures and returns.
</cxx-Effects>
<p>
If a <code>serial_executor</code> is destroyed inside a closure running on
that <code>serial_executor</code> object, the behavior is undefined. 
<cxx-note> one possible behavior is deadlock.
</p>
</cxx-remarks>
</cxx-function>

<cxx-function>
<cxx-signature>executor&amp; serial_executor::underlying_executor()</cxx-signature>
<cxx-Returns> The underlying executor that was passed to the constructor.</cxx-Returns>
</cxx-function>

</cxx-section>

<cxx-section id="executors.classes.loop">
<h1>Class <code>loop_executor</code></h1>

</cxx-section>

<cxx-section id="executors.classes.loop.syn">
<h1>Header <code>&lt;experimental/loop_executor></code> synopsis</h1>

<pre>
namespace std {
namespace experimental {
inline namespace concurrency_v1 {

  class loop_executor;

} // namespace concurrency_v1
} // namespace experimental
} // namespace std
</pre>

<p>
Class <code>loop_executor</code> is a single-threaded executor that executes closures by
taking control of a host thread. Closures are executed via one of three closure-
executing methods: <code>loop()</code>, <code>run_queued_closures()</code>, and
<code>try_run_one_closure()</code>. Closures are executed in FIFO order. Closure-executing
methods may not be called concurrently with each other, but may be called
concurrently with other member functions.
</p>

<pre>
class loop_executor : public executor {
public:
    loop_executor();
    virtual ~loop_executor();
    void loop();
    void run_queued_closures();
    bool try_run_one_closure();
    void make_loop_exit();
    // [executor methods omitted]
};
</pre>

<cxx-function>
  <cxx-signature>loop_executor::loop_executor()</cxx-signature>
  <cxx-Effects> Creates a <code>loop_executor</code> object. Does not spawn any threads. </p></cxx-Effects>
</cxx-function>

<cxx-function>
  <cxx-signature>loop_executor::~loop_executor()</cxx-signature>
  <cxx-Effects> Destroys the <code>loop_executor</code> object. Any closures that haven't been
  executed by a closure-executing method when the destructor runs will never be
  executed.</cxx-Effects>
  <cxx-Synchronization> Must not be called concurrently with any of the
  closure-executing methods.</cxx-Synchronization>
</cxx-function>

<cxx-function>
  <cxx-signature>void loop_executor::loop()</cxx-signature>
  <cxx-Effects> Runs closures on the current thread until <code>make_loop_exit()</code> is called.</cxx-Effects>
  <cxx-Requires> No closure-executing method is currently running.</cxx-Requires>
</cxx-function>

<cxx-function>
<cxx-signature>void loop_executor::run_queued_closures()</cxx-signature>

<cxx-Effects> Runs closures that were already queued for execution when this
function was called, returning either when all of them have been executed or
when <code>make_loop_exit()</code> is called. Does not execute any additional closures that
have been added after this function is called. Invoking <code>make_loop_exit()</code> from
within a closure run by <code>run_queued_closures()</code> does not affect the behavior of
subsequent closure-executing methods.</cxx-Effects>

<cxx-note>
this requirement disallows an implementation like
<pre>
void run_queued_closures() {
    add([](){make_loop_exit();});
    loop();
}
</pre>


because that would cause early exit from a subsequent invocation of <code>loop()</code>.
</cxx-note>

<cxx-Requires> No closure-executing method is currently running.</cxx-Requires>

<cxx-Remarks> This function is primarily intended for testing.</cxx-Remarks>
</cxx-function>

<cxx-function>
<cxx-signature>bool loop_executor::try_run_one_closure()</cxx-signature>

<cxx-Effects> If at least one closure is queued, this method executes the next
closure and returns.</cxx-Effects>

<cxx-Returns> <code>true</code> if a closure was run, otherwise <code>false</code>.</cxx-Returns>

<cxx-Requires> No closure-executing method is currently running.</cxx-Requires>

<cxx-Remarks> This function is primarily intended for testing.</cxx-Remarks>
</cxx-function>

<cxx-function>
<cxx-signature>void loop_executor::make_loop_exit()</cxx-signature>

<cxx-effects>
 Causes <code>loop()</code> or <code>run_queued_closures()</code> to finish executing
closures and return as soon as the current closure has finished. There is no
effect if <code>loop()</code> or <code>run_queued_closures()</code> isn't currently executing.
</cxx-effects>
<cxx-notes>
 <code>make_loop_exit()</code> is typically called from a closure. After a closure-
executing method has returned, it is legal to call another closure-executing
function. 
</cxx-notes>
</cxx-function>

</cxx-section>

<cxx-section id="executors.classes.inline">
<h1>Class <code>inline_executor</code></h1>

</cxx-section>
<cxx-section id="executors.classes.inline.syn">
<h1>Header <code>&lt;experimental/inline_executor></code> synopsis</h1>

<pre>
namespace std {
namespace experimental {
inline namespace concurrency_v1 {

  class inline_executor;

} // namespace concurrency_v1
} // namespace experimental
} // namespace std
</pre>

<p>
Class <code>inline_executor</code> is a simple executor which intrinsically only provides the <code>add()</code>
interface as it provides no queuing and instead immediately executes work on the calling thread.
This is effectively an adapter over the executor interface but keeps everything on the caller's
context.
</p>

<pre>
class inline_executor : public executor {
public
    explicit inline_executor();
    // [executor methods omitted]
};
</pre>

<cxx-function>
<cxx-signature>inline_executor::inline_executor()</cxx-signature>

<cxx-effects>
 Creates a dummy executor object which only responds to the <code>add()</code>
call by immediately executing the provided function in the caller's thread.
</cxx-effects>
</cxx-function>

</cxx-section>

<cxx-section id="executors.classes.thread">
<h1>Class <code>thread_per_task_executor</code></h1>

</cxx-section>
<cxx-section id="executors.classes.thread.syn">
<h1>Header <code>&lt;experimental/thread_per_task_executor></code> synopsis</h1>

<pre>
namespace std {
namespace experimental {
inline namespace concurrency_v1 {

  class thread_per_task_executor;

} // namespace concurrency_v1
} // namespace experimental
} // namespace std
</pre>

<p>
Class <code>thread_per_task_executor</code> is a simple executor that executes each task (closure)
on its own <code>std::thread</code> instance.
</p>

<pre>
class thread_per_task_executor : public executor {
public:
    explicit thread_per_task_executor();
    ~thread_per_task_executor();
    // [executor methods omitted]
};
</pre>

<cxx-function>
<cxx-signature>thread_per_task_executor::thread_per_task_executor()</cxx-signature>
<cxx-effects>Creates an executor that runs each closure on a separate thread.</cxx-effects>
</cxx-function>

<cxx-function>
<cxx-signature>thread_per_task_executor::~thread_per_task_executor()</cxx-signature>
<cxx-effects> Waits for all added closures (if any) to complete, then joins and
destroys the threads.</cxx-effects>
</cxx-function>

</cxx-clause>
